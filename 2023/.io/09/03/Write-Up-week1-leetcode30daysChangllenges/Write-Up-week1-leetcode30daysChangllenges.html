<hr>
<h2 id="title-Write-Up-week1-leetcode30天挑战author-Timdate-2023-09-03-15-47-31categories-计算机tags-算法"><a href="#title-Write-Up-week1-leetcode30天挑战author-Timdate-2023-09-03-15-47-31categories-计算机tags-算法" class="headerlink" title="title: Write Up|week1|leetcode30天挑战author: Timdate: 2023-09-03 15:47:31categories: 计算机tags: 算法"></a>title: Write Up|week1|leetcode30天挑战<br>author: Tim<br>date: 2023-09-03 15:47:31<br>categories: 计算机<br>tags: 算法</h2><h2 id="Day1-leetcode136-SingleNumber"><a href="#Day1-leetcode136-SingleNumber" class="headerlink" title="Day1_leetcode136_SingleNumber"></a>Day1_leetcode136_SingleNumber</h2><p>Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.You must implement a solution with a linear runtime complexity and use only constant extra space.</p>
<ul>
<li><p>第一时间想到的方法是直接双循环，对于每个元素，重新遍历一次数组统计出现的次数，若次数为1则输出，很简单，不再赘述。</p>
</li>
<li><p>第二个思路同上，不过在时间上做了优化，使用hashMap统计出现的次数</p>
</li>
<li><p>最高效的方法是通过位运算的一些基本性质实现：异或的性质</p>
</li>
<li><ul>
<li>由 A ^ A &#x3D; 0, A ^ 0 &#x3D; A, A ^ B &#x3D; B ^ A</li>
</ul>
</li>
<li><ul>
<li>易得： A ^ B ^ B &#x3D; A; A ^ B ^ B ^ C ^ C ^ D ^ D ^ … &#x3D; A</li>
</ul>
</li>
<li><ul>
<li>只要将每个元素放在一起做异或运算，得到的结果就是只出现一次的元素！</li>
</ul>
</li>
</ul>
<h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><pre><code>int singleNumber(int* nums, int numsSize)
{
//使用位元运算:   ^ bitwise XOR
//最为泛用： 所有数据都是由0, 1组成 
    int n = nums[0];
    for (int i = 1; i &lt; numsSize; i++)
    {
        n ^= nums[i];
        // n = nums[0] ^ nums[1] ^ ... nums[numsSize - 1];
    }
    return n;
}
</code></pre>
<p>位运算还是要熟悉的，有时能极大的简化题目</p>
<h2 id="Day2-leetcode202-HappyNumber"><a href="#Day2-leetcode202-HappyNumber" class="headerlink" title="Day2_leetcode202_HappyNumber"></a>Day2_leetcode202_HappyNumber</h2><p>Write an algorithm to determine if a number n is happy.<br>A happy number is a number defined by the following process:<br>Starting with any positive integer, replace the number by the sum of the squares of its digits.<br>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.<br>Those numbers for which this process ends in 1 are happy.<br>Return true if n is a happy number, and false if not.</p>
<ul>
<li>这是一个典型的circle detection问题，经典的解法为快慢双指针</li>
<li>我第一时间想到的也是最直接的解法：每经过一次变换，就将变换后的值存在一个数组中，并检查数组中有没有相同的值</li>
<li>如果把所有的状态都抽象成一个个节点，然后由其出现的顺序连成一个链表，那么这个问题自然就变成了判断一个链表是否闭合。</li>
<li><ul>
<li>进而就可以采用快慢双指针的解法来判断了。</li>
</ul>
</li>
<li><ul>
<li>这或许设计到一个思想，化时间为空间：把我们要研究的一个个随着时间不断变化的状态”摊开”成一个状态表(或者图)，这样就直观清晰多了，也能更好的帮助我们掌握其性质<br><img src="/p2.jpg" alt="p2"><br><img src="/p3.jpg" alt="p3"></li>
</ul>
</li>
<li><ul>
<li>如图，这些状态在逻辑上是线性结构，我们自然可以用线性结构的一些经典方法去分析</li>
</ul>
</li>
<li>这题还有一点要注意的就是如何将number每个位上的数字分离出来，不过这算是基本技能了把</li>
</ul>
<h3 id="Implement-1"><a href="#Implement-1" class="headerlink" title="Implement"></a>Implement</h3><p>法1：存储到数组中再检查是否重复</p>
<pre><code>int transfer_function(int n){
    int res = 0;
    int d = 0;
    while(n != 0)
    {
        d = n % 10;
        n /= 10;
        res += d * d;
    }
    return res;
}

int is_contained(int* arr, int arr_size, int num)
{
    for(int i = 0; i &lt; arr_size; i++)
    {
        if (arr[i] == num) return 1;
    }
    return 0;
}

int isHappy(int n)
{
    //C语言中实现 动态数组 的方法
    int history[10000];
    int size = 0;   //给出一个足够大的空数组，再加一个变量记录已经使用的空间
    while (n != 1)
    {
        if (is_contained(history, size, n)) return 0;
        history[size++] = n;
        n = transfer_function(n);
    }
    return 1;
}
</code></pre>
<p>法2：快慢双指针判断是否闭合</p>
<pre><code>int transfer_function(int n){
    int res = 0;
    int d = 0;
    while(n != 0)
    {
        d = n % 10;
        n /= 10;
        res += d * d;
    }
    return res;
}

int isHappy(int n)
{
    int slow = n;
    int fast = n;

    do {
        slow = transfer_function(slow);  //乌龟一次走一步
        fast = transfer_function(fast);
        fast = transfer_function(fast);    //兔子一次走两步
    } while(slow != fast);

    return slow == 1;
}
</code></pre>
<h2 id="Day3-leetcode53-Maximum-Subarray"><a href="#Day3-leetcode53-Maximum-Subarray" class="headerlink" title="Day3_leetcode53_Maximum Subarray"></a>Day3_leetcode53_Maximum Subarray</h2><p>Given an integer array <strong>nums</strong>, find the<br>subarray with the largest sum, and return its sum.<br>A subarray is a contiguous part of an array.</p>
<ul>
<li>第一个角度：这是最经典的动态规划问题(dynamic programming)。</li>
<li><ul>
<li>我们这样看这个问题:</li>
</ul>
</li>
<li><ul>
<li>规定 sum[i]是所有以元素arr[i]为结尾的子数组中(可能有一个或很多个)，和最大的那个子数组的和</li>
</ul>
</li>
<li><ul>
<li>那么 sum[i]的值一定收到sum[i-1]的影响，且该影响是确定的，称为 <strong>状态转换</strong></li>
</ul>
</li>
<li><ul>
<li>在本题中，该影响为</li>
</ul>
</li>
</ul>
<pre><code>    sum[i] = sum[i-1] + arr[i]  (if arr[i]&gt;0)
             sum[i-1]           (if arr[i]&lt;=0)
</code></pre>
<ul>
<li><ul>
<li>我们求出所有的sum[i], 再输出最大的那个即可， 这些状态在逻辑上也是线性的</li>
</ul>
</li>
<li><p>第二个角度：线段树 and 分治法， 把整个数组看成一条线段(索引)</p>
</li>
<li><ul>
<li>基本思想：将大线段不断地分成小线段(最终分成长度为1的小线段)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>小线段性质易分析；(性质&#x2F;状态 status: 如最大元素，求和，子数组和等)</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>由小线段性质推导大线段的性质(递归)</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>以数组{-2,1,-3,4,-1,2,1,-5,4}为例子，其长度为9<br><img src="/images/p4.jpg" alt="Alt text"></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>在逻辑上，每个(子)线段的关系是树状的，故称为线段树</li>
</ul>
</li>
<li><ul>
<li>在本题中，为了求到整条线段的最大子数组和，我们对其status规定如下</li>
</ul>
</li>
</ul>
<pre><code>    Status
    {
        int left_sum;  //以最左侧元素为起点的子线段的最大和
        int right_sum;  //以最右侧元素为终点的子线段的最大和
        int total_sum;  //整个线段所有元素的和
        int max_sum;    //整个线段的最大子数组和
    }
</code></pre>
<ul>
<li><ul>
<li>易得对于长度为1的子线段(子数组)，其4个状态值都等于它本身</li>
</ul>
</li>
<li><ul>
<li>接下来探讨：如何由子线段的status推导出父线段的status</li>
</ul>
</li>
</ul>
<pre><code>    father.left_sum = max{leftChild.left_sum, leftChild.total_sum+rightChild.left_sum};
    father.right_sum = max{rightChild.right_sum,rightChild.total_sum+leftChild.right_sum};
    father.total_sum = leftChild.total_sum+rigtChild.total_sum;
    father.max_sum = max{left_sum, right_sum, leftChild.right_sum+rightChild.left_sum};
    //这个有点难想到
</code></pre>
<ul>
<li><ul>
<li>完成了这些工作，本题就迎刃而解了</li>
</ul>
</li>
</ul>
<h3 id="Implement-2"><a href="#Implement-2" class="headerlink" title="Implement"></a>Implement</h3><p>动态规划方法</p>
<pre><code>int maxSubArray(int* nums, int numsSize) {
    int arr_i_subarr[100000];
    arr_i_subarr[0] = nums[0];

    //这是状态转换过程
    for (int i = 0; i &lt; numsSize - 1; i++)
    {
        arr_i_subarr[i + 1] = arr_i_subarr[i] &gt;= 0 ?
                              arr_i_subarr[i] + nums[i + 1] : nums[i + 1];
    }
    int res = arr_i_subarr[0];
    for (int i = 0; i &lt; numsSize; i++)
    {
        //printf(&quot;%d\n&quot;, arr_i_subarr[i]);
        res = arr_i_subarr[i] &gt; res ? arr_i_subarr[i] : res;
    }
    return res;
}
</code></pre>
<p>线段树分治法：</p>
<pre><code>struct Status{
    /*一个(子)序列的状态*/
 
    int lSum;   //以最左侧元素为起始的最大子序列和
    int rSum;   //以最右侧元素为末
    int tSum;   //整个序列和
    int mSum;   //最大子序列和
};

struct Status function_push(struct Status l_arr, struct Status r_arr){
    /*由左右两个子序列的status推导出原序列的status， 这是本题的核心*/
    int t_sum = l_arr.tSum + r_arr.tSum;
    int l_sum = fmax(l_arr.lSum, l_arr.tSum + r_arr.lSum);
    int r_sum = fmax(r_arr.rSum, r_arr.tSum + l_arr. rSum);
    int m_sum = fmax(fmax(l_arr.lSum, r_arr.rSum), l_arr.rSum + r_arr.lSum);
    return (struct Status){l_sum, r_sum, t_sum, m_sum};
}

struct Status function_get_status(int* arr, int l, int r){
    /*获取arr中从l到r的序列的状态*/
    /*由递归实现*/

    if (l == r) //边界条件:当子序列只有一个数时，所有的状态值都是一样的
        return (struct Status){arr[l], arr[l], arr[l], arr[l]};
    int m = (l + r) / 2; //mid
    struct Status l_arr = function_get_status(arr, l, m);
    struct Status r_arr = function_get_status(arr, m + 1, r);
    return function_push(l_arr, r_arr);
}


int maxSubArray(int* nums, int numsSize) {
    return function_get_status(nums, 0, numsSize - 1).mSum;
}
</code></pre>
<h2 id="Day4-leetcode283-Move-Zeroes"><a href="#Day4-leetcode283-Move-Zeroes" class="headerlink" title="Day4_leetcode283_Move Zeroes"></a>Day4_leetcode283_Move Zeroes</h2><p>Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements.<br>Note that you must do this in-place without making a copy of the array.</p>
<ul>
<li>第一想法：遍历一次数组，遇到0就让之后所有的元素前移1位，并在数组的末位补一个0</li>
<li><ul>
<li>很直接粗暴，也符号题目要求没用新空间，TC &#x3D; O(n^2)</li>
</ul>
</li>
<li>题解里用的算法，我还没想出很好的名字</li>
<li><ul>
<li>用两个指针，一个指针遍历一遍数组，记录所有非零元素的位置</li>
</ul>
</li>
<li><ul>
<li>另一个指针：在前者遇到非零元素时，将所指元素更改为前者的值并自增</li>
</ul>
</li>
<li><ul>
<li>最后再用2号指针补0</li>
</ul>
</li>
<li><ul>
<li>这是很精妙的算法，相当与用一个指针近似存储了非0元素，”获得”了额外的空间，不知是怎么想出来的</li>
</ul>
</li>
<li><ul>
<li>也许线性结构的数据都可以用双指针来处理吧???</li>
</ul>
</li>
</ul>
<h3 id="Implement-3"><a href="#Implement-3" class="headerlink" title="Implement"></a>Implement</h3><p>法1:</p>
<pre><code>void moveZeroes(int* nums, int numsSize){
    int i = 0;
    int nonzero_counter = 0;
    for (int l = 0; l &lt; numsSize; l++)
    {
        if (nums[l] != 0) nonzero_counter++;
    }
    while (i &lt; nonzero_counter){
        if (nums[i] != 0) i++;
        else{
            for (int j = i; j &lt; numsSize - 1; j++)
            {
                nums[j] = nums[j + 1];
            }
            nums[numsSize - 1] = 0;
        }
    }
    for (int k = 0; k &lt; numsSize; k++){
        printf(&quot;%d&quot;, nums[k]);
    }
}
</code></pre>
<p>法2:(双指针)</p>
<pre><code>void moveZeroes(int* nums, int numsSize){
    int i = 0;
    int j = 0;
    while (i &lt; numsSize){
        if(nums[i]){
            nums[j++] = nums[i];
        }
        i++;
    }
    while (j &lt; numsSize){
        nums[j++] = 0;
    }
    for (int k = 0; k &lt; numsSize; k++){
        printf(&quot;%d&quot;, nums[k]);
    }
}
</code></pre>
<h2 id="Day5-leetcode122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Day5-leetcode122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Day5_leetcode122_Best Time to Buy and Sell Stock II"></a>Day5_leetcode122_Best Time to Buy and Sell Stock II</h2><p>You are given an integer array prices where prices[i] is the price of a given stock on the ith day.<br>On each day, you may decide to buy and&#x2F;or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.<br>Find and return the maximum profit you can achieve.</p>
<p><em>讲个笑话。某人问：“我刷完了所有的股票题，现在可以入股市了吗？”</em></p>
<ul>
<li>最直接的思路就是低买高卖(这也被叫做贪心算法)</li>
<li><ul>
<li>若未持有股票，当本日股价低于明日股价时买入；若持有，则当本日股价低于高于明日股价时卖出</li>
</ul>
</li>
</ul>
<pre><code>if (prices[i] &lt; prices[i + 1] &amp;&amp; hold == 0)
{
    function_buy(&amp;prices[i], &amp;profit, &amp;hold);
}
else if (prices[i] &gt; prices[i + 1] &amp;&amp; hold ==1)
{
        function_sell(&amp;prices[i], &amp;profit, &amp;hold);
}
</code></pre>
<ul>
<li><ul>
<li>经过一点点数学推导，总结出以下公式</li>
</ul>
</li>
</ul>
<pre><code>max_profit = ∑(max(price[i + 1] - price[i], 0));
//大于0的差价和
</code></pre>
<ul>
<li><ul>
<li>如果我们吧第i天结束时的最大利润pro[i]看成一个状态，那么这题也可以看成是动态规划类的问题。相邻状态的关系也是线性的(逻辑上)</li>
</ul>
</li>
<li>网上还有另一种dp的解法，不过那个我觉得太蠢了，直说下大概思路</li>
</ul>
<pre><code>规定 dp[i][0]: 第i天结束后手里没股票的最大利润；
    dp[i][1]: 有股票的~
则有: dp[i][0]=max{dp[i-1][1]+prices[i],dp[i-1][0]}    第i天卖了或者没卖
      dp[i][1]=max{dp[i-1][0]-prices[i],dp[i-1][1]}    买了或没买
</code></pre>
<h3 id="Implement-4"><a href="#Implement-4" class="headerlink" title="Implement"></a>Implement</h3><pre><code>int maxProfit(int* prices, int pricesSize){
    int profit = 0;
    for (int i = 0; i &lt; pricesSize - 1; i++)
    {
        profit += fmax(prices[i + 1] - prices[i], 0);
        //if prices[i+1] &gt; prices[i]: profit += prices[i+1]-price[i]
    }
}
</code></pre>
<h2 id="Day6-leetcode49-Group-Anagrams"><a href="#Day6-leetcode49-Group-Anagrams" class="headerlink" title="Day6_leetcode49_Group Anagrams"></a>Day6_leetcode49_Group Anagrams</h2><p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p>
<p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<ul>
<li>这是一个典型的哈希表字符匹配问题，大致流程如下：<br><img src="/images/p1.png" alt="Alt text"></li>
<li><ul>
<li>hash的方法有很多种：比如将原strs[i]排序后得到的新string作为hash值，或者以每个字母对应一个不同的质数，将单词中所有字母的对应质数求和作为hash值；理论上只要能保证所有Anagrams的hash值一致即可<br><em>我最初的想法是用一个哈希表作为hash值，存储每个字母出现的次数，不过这个用C语言很难实现，而且效率很低</em></li>
</ul>
</li>
</ul>
<h3 id="Implement-5"><a href="#Implement-5" class="headerlink" title="Implement"></a>Implement</h3><p>C++实现，比C简单很多</p>
<pre><code>class Solution {
public:
    string function_hash(string s){
        string hash_value = s;
        sort(hash_value.begin(), hash_value.end());
        return hash_value;
    }

    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        unordered_map&lt;string, vector&lt;string&gt;&gt; res;
        vector&lt;vector&lt;string&gt;&gt; ans;        

        for (const string&amp; s : strs){
            res[function_hash(s)].push_back(s);
        }

        for (const auto&amp; pair : res){
            ans.push_back(pair.second);
        }

        return ans;
    }
};
</code></pre>
<p>也可以用C语言，算是加深一下对底层结构的理解</p>
<pre><code>/**
 * Return an int_pointer of the size of the return_array *returnSize.存储结果数组的大小，即分组的数量
 * The sizes of each elements are returned as *returnColumnSizes array.存储每个分组的大小。
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

typedef struct {
    char key[101];  //键值
    int count;      //相同键值的字符串数量
    int id[100];    //对应value的字符串在原数组strs的索引
    UT_hash_handle hh;  
} HashTable;

HashTable *g_hashTable = NULL;  //HashTable指针,用于存储字母异位词的分组信息

int cmp(const void *a,const void *b)
{
    //一个用于比较字符的函数cmp。在后面的代码中，该函数将用于对字符串中的字符进行排序(qsort)。
    return *(char*)a - *(char*)b;
}


char *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){
    if(strsSize == 0) {
        //边界条件，传入空数组的情况
        *returnSize = 0;
        return NULL;
    }

    // 遍历输入的字符串数组，将相应数据存入哈希表中
    for(int i = 0;i &lt;strsSize; ++i) {
        // tmp存储当前字符串,进行hash处理后作为对应strs[i]的key值
        char tmp[101];
        strcpy(tmp,strs[i]);
        int len = strlen(tmp);

        //对tmp进行hash处理
        qsort(tmp,len,sizeof(char),cmp);

        // 在哈希表中通过key值tmp查找strs[i]对应的分组
        HashTable *tmpHash = NULL;
        HASH_FIND_STR(g_hashTable,tmp,tmpHash);

        // 如果未找到对应的分组，代表此时是该key第一次出现，strs[i]是本组第一个元素
        // 此时将在哈希表中创造一个以tmp为key值的新节点
        if(tmpHash == NULL) {
            // 创建一个新的HashTable节点
            HashTable *new = calloc(1,sizeof(HashTable));
            strcpy(new-&gt;key,tmp);
            new-&gt;count = 0;
            HASH_ADD_STR(g_hashTable,key,new);
            tmpHash = new;
        }

        // 接着将strs[i]的索引（即i）添加到分组对应的id数组中
        //并且计数器count + 1， 代表strs[i]已被添加到该分组中
        tmpHash-&gt;id[(tmpHash-&gt;count)++] = i;
    }

    // 遍历哈希表，构建结果数组（输出）
    HashTable *tmp1 = NULL;
    HashTable *tmp2 = NULL;
    int retLen = HASH_COUNT(g_hashTable);   //分组的数量
    char ***ans = calloc(retLen,sizeof(char**));//构建结构数组，输出
    int ansLen = 0;
    returnColumnSizes[0] = calloc(retLen,sizeof(int));

    //HASH_ITER循环遍历哈希表
    //HASH_ITER是一个宏定义，程序执行时被替换为一个循环。
    //一次遍历一组
    HASH_ITER(hh,g_hashTable,tmp1,tmp2) {
        // 为当前分组分配内存
        ans[ansLen] = calloc(tmp1-&gt;count,sizeof(char*));
        returnColumnSizes[0][ansLen] = tmp1-&gt;count;

        // 将当前分组的字符串添加到结果数组中
        for(int i = 0; i &lt; tmp1-&gt;count; ++i) {
            ans[ansLen][i] = strs[tmp1-&gt;id[i]];
        }
        ansLen++;
        // 从哈希表中删除已处理的分组节点
        HASH_DEL(g_hashTable,tmp1);
        free(tmp1);
    }
    // 设置返回结果的大小
    *returnSize = ansLen;
    return ans;
}
</code></pre>
<p>哈希表的结点是这样设计的：<br><img src="/images/p5.jpg" alt="Alt text"></p>
<h2 id="Day7-leetcode1426-Count-Elements"><a href="#Day7-leetcode1426-Count-Elements" class="headerlink" title="Day7_leetcode1426_Count Elements"></a>Day7_leetcode1426_Count Elements</h2><p>给你一个整数数组 arr， 对于元素 x ，只有当 x + 1 也在数组 arr 里时，才能记为 1 个数。<br>如果数组 arr 里有重复的数，每个重复的数单独计算。<br>输出符合条件元素的计数。</p>
<ul>
<li>这题最方便也是用哈希表，不过比上题简单很多，直接记录每个数字出现的次数就行了</li>
<li><ul>
<li>以原数字为key，其在数组中出现的次数为value存入哈希表中</li>
</ul>
</li>
<li><ul>
<li>只要连续两个数字的出现次数都不为0，则对前者计数</li>
</ul>
</li>
</ul>
<h3 id="Implement-6"><a href="#Implement-6" class="headerlink" title="Implement"></a>Implement</h3><pre><code>int countElements(int* arr, int arrSize){
    int ans = 0;
    int min = arr[0];
    int max = arr[0];

    //计算最大最小值再申请数组，可以省点空间
    for (int i = 0; i &lt; arrSize; i++)
    {
        min = arr[i] &lt; min ? arr[i] : min;
        max = arr[i] &gt; max ? arr[i] : max;
    }

    int len = max - min + 1;
    int* map = (int*)calloc(len, sizeof(int));

    for (int i = 0; i &lt; arrSize; i++){
        map[arr[i] - min]++;
    }

    for (int i = 0; i &lt; len - 1; i++){
        //key
        if (map[i]!= 0 &amp;&amp; map[i + 1] != 0){
            ans += map[i];
        }
    }

    free(map);

    return ans;
}
</code></pre>
